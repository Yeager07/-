# Работа #7 - Реализация механики выстрела с обратной связью
Отчет по лабораторной работе #7 выполнил(а):
- Есипенко Игорь Ярославович
- РИ-320936
- АТ-09
# Цель: научиться создавать механику выстрела и реализовать связь игрового процесса с интерфейсом пользователя в среде разработки Unity

![image](https://github.com/user-attachments/assets/844114d9-74c0-4039-b053-d3572e0de0ed)

Рекомендуемые источники для изучения:
1.	User interface in Unity Documentation
2.	Theme in lecture materials

# Вводные
В играх аудиовизуальную информацию, которую получает пользовать, называют обратной связью. В этой практической работы мы будем создавать различную аудиовизуальную обратную связь, которая позволяет получить более качественный игровой опыт. Мы рассмотрим:
-	визуальную обратную связь при разбиении объекта на множество маленьких частей
-	визуальную обратную связь в графическом интерфейсе
-	звуковую обратную связь при стрельбе и нанесении урона
Различные виды обратной связи улучшают взаимодействия пользователя с игровым миром.
# Задание 1. Управление с видом от первого лица
1.1 Для начала создадим прототип персонажа и опишем его управление. В качестве персонажа будем использовать объект Capsule:

![image](https://github.com/user-attachments/assets/64bf808b-dc37-4808-862b-ba9f54d01974)

1.2 Скрипт файл для управления персонажем приведен ниже. Убедитесь, что после добавления функций перемещения, у игрока есть возможность движения по сцене. Подберите переменные управления так, чтобы управление движением было максимально удобным и правдоподобным:

```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MovePlayer : MonoBehaviour
{
   private Rigidbody rb;

   public float speed = 10.0f;
   public float maxSpeed = 15.0f;
   public float rotationSpeed = 360.0f;

   void Start()
   {
       rb = GetComponent<Rigidbody>();
   }

   void Update()
   {
       // Получаем ввод от клавиатуры
       float moveHorizontal = Input.GetAxis("Horizontal");
       float moveVertical = Input.GetAxis("Vertical");

       // Получаем ввод от мыши
       float rotationX = transform.localEulerAngles.y + Input.GetAxis("Mouse X") * rotationSpeed * Time.deltaTime;
       transform.localEulerAngles = new Vector3(0, rotationX, 0);

       // Применяем силу для перемещения в горизонтальной и вертикальной плоскостях
       Vector3 movement = new Vector3(moveHorizontal, 0.0f, moveVertical);
       rb.AddRelativeForce(movement * speed);

       // Ограничение скорости чтобы игрок не разгонялся больше значения maxSpeed
       Vector3 clampedVelocity = Vector3.ClampMagnitude(rb.velocity, maxSpeed);
       rb.velocity = clampedVelocity;
   }
}
```

## Добавил на сцену объект сферу - игрок и куб – землю. Сделал объект камера дочерним для объекта персонаж и разместил так, чтобы при запуске сцены был “вид от первого лица”. Создал скрипт файл для управление передвижением персонажа и применил его на сфере.

![image](https://github.com/user-attachments/assets/07939d4d-d00a-4793-ada8-220146674824)

1.3 Опишите, какими элементами управления реализовано перемещение персонажа. Как и какие переменные влияют на скорость движения:

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Чтобы движение персонажа было максимально комфортным и правдоподобным для себя, подобрал следующие значения переменных: Speed = 5; maxSpeed = 15; rotationSpeed = 270.
Управление персонажем реализовано с помощью клавиш клавиатуры (A, D – перемещение по горизонтали; W, S – перемещение по вертикали), а также движением компьютерной мыши (поворот персонажа влево и вправо).
На скорость движения персонажа влияют переменные Speed и maxSpeed, где Speed – начальная скорость передвижения игрока, а maxSpeed – максимальная скорость, которую персонаж может достичь/развить; есть ещё переменна rotationSpeed, которая отвечает за плавность вращения персонажа вдоль собственной оси Y.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Задание 2. Создание стрельбы объектом
2.1 Создайте префаб пули. Префаб — это шаблон объекта, который неоднократно используется на сцене. Например, многократно создаётся на сцене при нажатии на кнопку мыши:

![image](https://github.com/user-attachments/assets/f93119d9-800c-4bc6-be4e-b0057c07a268)

2.2 Создайте систему объектов, которая будет играть роль оружия и точки вылета пули:

![image](https://github.com/user-attachments/assets/44c7eb78-fa09-4387-aa37-bb09e62ff613)

2.3 В скрипт-файле BulletSpawner реализуйте условие генерации пуль при нажатии на левую кнопку мыши:

```C#
using UnityEngine;

public class BulletSpawner : MonoBehaviour
{
    public GameObject BulletPrefab;
    public float BulletVelocity = 20f;

    void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            GameObject newBullet = Instantiate(
                BulletPrefab, transform.position, transform.rotation);
            newBullet.GetComponent<Rigidbody>().velocity =
                transform.forward * BulletVelocity;
        }
    }
}
```
## Добавил к персонажу куб, обозначающий оружие и разместил его нужным образом. Добавил на сцену пустой объект, обозначающий место появления пули. Создал префаб пули. Создал скрипт для спауна префаба пули в месте пустого объекта и назначил его на объект BulletSpawner, добавив в параметрах префаб пули. Сделал объекты Weapon и BulletSpawner дочерними для персонажа.

![image](https://github.com/user-attachments/assets/e17e2709-b6d7-4127-a518-2c7c73add9eb)

2.4 Подумайте над тем, как завершить настройку выстрела (вылета пуль при нажатии на кнопку мыши). Напишите, что нужно сделать для завершения настройки:

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
По моему мнению, для завершения настройки вылета пули при нажатии на кнопку мыши, нужно обеспечить пулю гравитацией, то есть перевести параметр Use Gravity компонента Rigidbody из состояния false в состояние true.
Данное действие осуществляется следующей строчкой кода:

```C#
newBullet.GetComponent<Rigidbody>().useGravity = true;
```
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Задание 3. Детектирование стрельбы по объектам
3.1 При попадании по объектам можно вызывать различные события. Для определения попаданий обычно используется метод OnCollisionEnter(). При этом детектирование попадания может происходить как в “объекте-жертве”, так и в пуле (летящем объекте). В лекции, посвященной событиям OnCollision мы проверяли объектом Bullet, с какими игровыми объектами произошло столкновение. В этом примере мы рассмотрим другой пример, когда столкновение будет определяться не внутри пули, а внутри “жертвы” - Enemy. Создадим необходимые примитивы:

![image](https://github.com/user-attachments/assets/f7b5bc66-f947-4769-9c23-dcb34ad9b1ae)

3.2 Реализуем функционал, при котором Enemy будет разлетаться на множество мелких частей при попадании Bullet. Для этого назначьте на Enemy скрипт файл с именем Enemy.cs и добавьте в скрипт следующий функционал:

```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Enemy : MonoBehaviour
{
   public GameObject cubePiecePrefab;
   public float explodeForce = 500f;

   private void OnCollisionEnter(Collision collision)
   {
       if (collision.gameObject.CompareTag("Bullet"))
       {
           ExplodeCube();
       }
   }

   private void ExplodeCube()
   {
       for (int x = 0; x < 4; x++)
       {
           for (int y = 0; y < 4; y++)
           {
               for (int z = 0; z < 4; z++)
               {
                   Vector3 piecePosition = transform.position + new Vector3(x, y, z) * 0.5f;
                   GameObject piece = Instantiate(cubePiecePrefab, piecePosition, Quaternion.identity);
                   Rigidbody pieceRigidbody = piece.GetComponent<Rigidbody>();
                   pieceRigidbody.AddExplosionForce(explodeForce, transform.position, 5f);
               }
           }
       }
       Destroy(gameObject);
   }
}
```

3.3 Разберитесь в работе скрипта, опишите как он работает:

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Работа скрипта выше:
Сначала вызывается метод OnCollisionEnter, который проверяет, пересеклись ли коллайдеры объекта Enemy, на который назначен данный скрипт, с объектом, у которого Tag = Bullet, если пересеклись, то вызывается метод ExplodeCube.
В методе ExplodeCube мы проходимся по трём циклам, в которых меняем значения переменных x, y и z , которые будут являться координатами; в строке “GameObject piece = … “ мы генерируем объект cubePiecePrefab на месте piecePosition, которое получили в строке “Vector3 piecePosition = …”; далее мы объявляем переменную pieceRigidbody, через которую будем осуществлять взаимодействие с параметрами компонента Rigidbody, назначенного на объект piece; в строке “pieceRigidbody.Add…” мы указываем, с какой силой и в каком направлении будут разлетаться наши части врага.
В последней строке мы разрушаем объект, на месте которого должны появиться его мелкие части.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3.34Для работы скрипта нужно поместить в переменную Cube Piece Prefab созданный ранее EnemyPart и подобрать значение силы “разлета” частей куба:

![image](https://github.com/user-attachments/assets/869cbcca-9922-4632-b7dd-e48a81d9a5a2)

3.5 Как вы заметили, анализируя скрипт в пункте 3.3, метод ExplodeCube вызывается в момент пересечения с тегом Bullet: CompareTag("Bullet"). Это значит, что префаб пули должен содержать соответствующий тег. Назначить тег на объект Bullet можно в верхней части окна инспектора:

![image](https://github.com/user-attachments/assets/20893b48-7fed-4853-b925-cd9d85b23385)

## Назначил на Bullet тег Bullet; Добавил на сцену куб Enemy и создал для него префаб EnemyPrefab; Назначил компонент Rigidbody на объект Enemy; Создал и назначил скрипт ScriptEnemy на объект Enemy.

## Сцена с кубом и его настройками

![image](https://github.com/user-attachments/assets/7988e505-25b5-4cd9-8c1e-5f52d2e789e7)

## Настройки префаба пули

![image](https://github.com/user-attachments/assets/080cf28d-edb8-4106-9a76-8790f1caa4ff)

3.6 Теперь, если всё сделано правильно, при попадании по Enemy, враг будет разлетаться на множество маленьких объектов. Так нами был реализован один из видов обратной связи, - визуальный. Именно так игрок понимает, что требуется делать в игре и получает удовольствие от игрового процесса, наблюдая за разрушением объектов. Поэкспериментируйте с различной силой “разлета” объектов кубиков. Увеличьте или уменьшите ее и подберите наиболее оптимальное значение на ваше усмотрение. Напишите, какое значение вы нашли и почему выбрали именно его:

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Для скорости разлёта объектов кубиков я выбрал значение = 200.
Данное значение выбрал из следующих соображений: размер пули и частей кубиков совпадает (0.2); скорость пули составляет 20 единиц; размер врага по одной из осей в 10 раз больше, чем размер пули => скорость разлёта частей кубиков должна быть в 10 раз больше, то есть 20*10=200.
Та и при данном значение, по моему мнению, разлёт частей кубиков выглядит более менее реалистично.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Задание 4. Создание звуковой обратной связи
4.1 Воспроизведение звуков происходит достаточно просто, нужно назначить AudioSource на объект, получать доступ к этому компоненту при определенных событиях. Далее реализуем воспроизведения звуков при выстреле. У нас уже есть скрипт-файл и объект BulletSpawner, который генерирует пули. Модернизируем BulletSpawner таким образом, чтобы при нажатии на левую кнопку мыши не только генерировались пули Bullets, но и воспроизводился звук:

![image](https://github.com/user-attachments/assets/8b6aaf1b-4895-4a3d-b80f-5a69ea0ec27f)

4.2 Изменим BulletSpawner.cs скрипт таким образом, чтобы при выстреле воспроизводился этот звук (новые строки кода отмечены как //NEW):

```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BulletSpawner : MonoBehaviour
{
   public GameObject BulletPrefab;
   AudioSource bulletSound; //NEW
   public float BulletVelocity = 20f;

   void Start(){
       bulletSound = GetComponent<AudioSource>(); //NEW
   }

   void Update()
   {
       if (Input.GetMouseButtonDown(0))
       {
           GameObject newBullet = Instantiate(
               BulletPrefab, transform.position, transform.rotation);
           newBullet.GetComponent<Rigidbody>().velocity =
               transform.forward * BulletVelocity;
          
           bulletSound.Play(); //NEW
       }
   }
}
```

4.3 Проверьте работу. При нажатии на левую кнопку мыши вместе с вылетом Bullet должен проигрываться звук.

## Скачал понравившийся звук выстрела и добавил его в Project; Изменил скрипт BulletSpawner, чтобы при нажатии ЛКМ вместе с выстрелом пули ещё проигрывался бы скачанный звук выстрела.

![image](https://github.com/user-attachments/assets/10b3b771-ec2c-4ba3-81f3-31e9c65f6578)

4.4 Самостоятельно реализуйте звук разрушения Enemy на множество маленьких объектов. Реализовать решение можно аналогично п 4.1 и 4.2, то есть нужно воспроизводить звук при наступлении соответствующего события. Предложите вариант реализации и опишите его:

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Для реализации воспроизведения звука при разрушении куба сделал следующее:
Добавил на сцену отдельный объект звук (Audio – Audio Source), после чего к нему добавил скачанный звук взрыва.
В скрипте добавил публичную переменную boomSound; В методе OnCollisionEnter в теле условия воспроизвожу данный звук “boomSound.Play();”, после чего вызываю метод ExplodeCube().
При соприкосновении куба с пулей куб разрушается, заменяясь на маленькие кубы, а звук продолжает воспроизводиться (пытался повторить пункты 4.1 и 4.2, но при вместе с разрушением куба пропадал и сам звук, из-за чего он просто не успевал проигрываться, поэтому прибегнул к данному решению).

```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ScriptEnemy : MonoBehaviour
{
    public GameObject cubePiecePrefab;
    public AudioSource boomSound; //NEW
    public float explodeForce = 500.0f;

    private void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.CompareTag("Bullet"))
        {
            boomSound.Play(); //NEW
            ExplodeCube();
        }
    }

    private void ExplodeCube()
    {
        for (int x = 0; x < 4; x++)
        {
            for (int y = 0; y < 4; y++)
            {
                for (int z = 0; z < 4; z++)
                {
                    Vector3 piecePosition = transform.position + new Vector3(x, y, z) * 0.5f;
                    GameObject piece = Instantiate(cubePiecePrefab, piecePosition, Quaternion.identity);
                    Rigidbody pieceRigidbody = piece.GetComponent<Rigidbody>();
                    pieceRigidbody.AddExplosionForce(explodeForce, transform.position, 5.0f);
                }
            }
        }

        Destroy(gameObject);
    }
}
```
## Настройки отдельно созданного объекта звука

![image](https://github.com/user-attachments/assets/0e0f8db9-51e9-434e-b3c2-5a6a7a5cc0b7)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Задание 5. Увеличение счётчика очков при попадании по объектам
5.1 Реализуем увеличение счетчика очков при попадании по Enemy. Также будем выводить информацию о количестве набранных очков на экран. Создайте текстовое поле, кликнув ПКМ в окне иерархии и выбрав UI - Text - TextMeshPro (будет предложено импортировать шрифты, соглашаемся).
5.2 По центру экрана появится текстовое поле. Элементы интерфейса принято крепить якорями к различным частям экрана, чтобы при изменении разрешения экрана элемент UI не смещался. Ниже приведён пример настройки поля Text в окне Inspector, который позволяет зафиксировать якорь этого поля в правой верхней части экрана:

![image](https://github.com/user-attachments/assets/ca9dbc9e-0e97-4150-b861-3f68f90b752a)

5.3 Чтобы по умолчанию на экране показывалась информативная надпись, поменяйте в поле Text выводимую текстовую информацию: Score: 00:

![image](https://github.com/user-attachments/assets/281fcd7d-1e29-470a-93f4-9a144b6a8d37)

5.4 Далее реализуем увеличение счётчика очков при попадании по врагу. Модифицируем скрипт Enemy.cs, добавив ссылку на объект TextMeshPro и будем передавать в него значение очков count, преобразованное в строковый формат:

```C#
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;

public class Enemy : MonoBehaviour
{
    public GameObject cubePiecePrefab;
    public float explodeForce = 500f;

    [SerializeField] TextMeshProUGUI textScore;
    private int count = 0;

    private void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.CompareTag("Bullet"))
        {
            ExplodeCube();
            AddScore();
        }
    }

    private void AddScore()
    {
        count += 10;
        textScore.text = "Score: " + count.ToString();
    }

    private void ExplodeCube()
    {
        for (int x = 0; x < 4; x++)
        {
            for (int y = 0; y < 4; y++)
            {
                for (int z = 0; z < 4; z++)
                {
                    Vector3 piecePosition = transform.position + new Vector3(x, y, z) * 0.5f;
                    GameObject piece = Instantiate(cubePiecePrefab, piecePosition, Quaternion.identity);
                    Rigidbody pieceRigidbody = piece.GetComponent<Rigidbody>();
                    pieceRigidbody.AddExplosionForce(explodeForce, transform.position, 5f);
                }
            }
        }
        Destroy(gameObject);
    }
}
```
5.4 Теперь в инспекторе объекта Enemy появится переменная для текстового поля. Перенесите в эту переменную созданное ранее текстовое поле. Проверьте, что при попадании по объекту Enemy происходит его разрушение, однако счёт очков не увеличивается. Как вы считаете, почему этого не происходит?

-------------------------------------------------------------------------------
Этого не происходит из-за того, что прогресс заработанных очков не сохраняется.
-------------------------------------------------------------------------------

5.5 Дело в том что прогресс заработанных очков не сохраняется. Для сохранения очков нужно завести отдельный класс и сделать его Синглтоном (согласно принципам ООП). В этом классе будем хранить значения счётчика. Создайте пустой объект на сцене, назовите его Progress и подключите к нему скрипт-файл Progress.cs:

![image](https://github.com/user-attachments/assets/d413a1cb-e15d-4497-8c8a-e4226b0ea294)

5.6 Содержимое скрипт-файла Progress.cs. В этом клссе-синглтоне переменная Score будет гарантированно хранить значение с достижениями игрока на сцене. Конструкция внутри метода Awake гарантирует, что класс Progress будет единственным:

```C#
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine;

[System.Serializable]
public class PlayerInfo
{
    public int Score = 0;
}

public class Progress : MonoBehaviour
{
    public PlayerInfo PlayerInfo;
    public static Progress Instance;

    private void Awake()
    {
        if (Instance == null)
        {
            transform.parent = null;
            DontDestroyOnLoad(gameObject);
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }
}
```
5.7 Теперь мы можем модифицировать скрипт-файл Enemy.cs, который будет сохранять счётчик очков:

```C#
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;

public class Enemy : MonoBehaviour
{
    public GameObject cubePiecePrefab;
    public float explodeForce = 500f;

    [SerializeField] TextMeshProUGUI textScore;

    private void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.CompareTag("Bullet"))
        {
            ExplodeCube();
            AddScore();
        }
    }

    void Start()
    {
        textScore.text = "Score: " + Progress.Instance.PlayerInfo.Score.ToString();   
    }

    private void AddScore()
    {
        Progress.Instance.PlayerInfo.Score += 10;
        textScore.text = "Score: " + Progress.Instance.PlayerInfo.Score.ToString();
    }


    private void ExplodeCube()
    {
        for (int x = 0; x < 4; x++)
        {
            for (int y = 0; y < 4; y++)
            {
                for (int z = 0; z < 4; z++)
                {
                    Vector3 piecePosition = transform.position + new Vector3(x, y, z) * 0.5f;
                    GameObject piece = Instantiate(cubePiecePrefab, piecePosition, Quaternion.identity);
                    Rigidbody pieceRigidbody = piece.GetComponent<Rigidbody>();
                    pieceRigidbody.AddExplosionForce(explodeForce, transform.position, 5f);
                }
            }
        }
        Destroy(gameObject);
    }
}
```

## Создал текстовое поле и изменил его содержимое на фразу “Score: 00”. Добавил на сцену пустой объект Progress, на который добавил скрипт ScriptProgress. Изменил скрипты ScriptEnemy и ScriptProgress так, как показано в пунктах выше. Запустил сцену – прибавление очков работает исправно.

## Настройки куба Enemy

![image](https://github.com/user-attachments/assets/655b1d3b-593b-4ae3-8c7c-2df414dbe1bb)

## Текстовое поле с настройками

![image](https://github.com/user-attachments/assets/d4979124-48a9-4cb8-8dea-fa152def37e7)

# Задание 6. Самостоятельная работа
6.1 С помощью SceneManager можно создавать условие перезагрузки сцены. В примере ниже происходит перезагрузка сцены, когда игрок набрал 30 очков. Чтобы условие корректно работала сцена должна называться как указано в скрипте - MainLevel:

```C#
if (Progress.Instance.PlayerInfo.Score == 30)
        {
            SceneManager.LoadScene("MainLevel");
        }
```

6.2 Подумайте, в какую часть кода нужно добавить данное условие, чтобы происходила перезагрузка сцены. Напишите свой вариант ответа:

------------------------------------------------------------------------------------------------------------------------------------------------
Данную часть кода добавил в метод AddScore в скрипт файле ScriptEnemy после строк, в которых идёт прибавление очков за попадание по врагу Enemy.
------------------------------------------------------------------------------------------------------------------------------------------------

6.3 Добавьте на сцену множество объектов Enemy. Реализуйте перезагрузку сцены, когда игрок наберет 100 очков.

## Добавил на сцене множество объектов Enemy (10 штук) и изменил условие в скрипте так, чтобы сцена перезапускалась, когда игрок наберёт 100 очков.

## Изменённая сцена 

![image](https://github.com/user-attachments/assets/0525e64f-4023-4663-ae31-9efc53eba7ff)

## Изменённый кусок кода

![image](https://github.com/user-attachments/assets/39e65a1d-f68f-40fc-be0b-c2f9cc88ebaa)

6.4 Напишите вывод о проделанной работе

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
В ходе данной лабораторной работы была проведена работа с звуковой и визуальной обратной связью при достижении какого-либо условия: визуальная – разрушение объекта Enemy при пересечении с объектом с тегом Bullet; звуковая: воспроизведение звука при выстреле по нажатию на ЛКМ, а также воспроизведение звука при разрушении объекта Enemy. Была реализована обратная связь с помощью изменения количества набранных очков, путём их увеличения при “убийстве” врага. Также была реализована перезагрузка сцены после достижения определённого количества очков, что позволяло продолжить “игровой процесс убийства врагов”.
Полученные знания со 100 процентной вероятностью пригодятся при создании каких-то собственных игр или симуляторов, в которых потребуется обратная связь для “общения” с игроком и оживления игрового процессв.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Ссылка на Package файл работы:
https://disk.yandex.ru/d/8bJ-ZsRxEt0zlg
